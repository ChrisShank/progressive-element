<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cells</title>
  </head>
  <body>
    <spreadsheet-app></spreadsheet-app>
  </body>

  <script type="module">
    import { findClosestIntention } from '../src/intentions';
    import { ProgressiveElement } from '../src/progressive-element';

    // This custom element is mainly just templating the spreadsheet.
    class SpreadsheetApp extends ProgressiveElement {
      static tagName = 'spreadsheet-app';
      static delegatedEvents = ['focusin', 'focusout'];

      cells = new Map();

      connectedCallback() {
        let html = '<spreadsheet-header></spreadsheet-header>';
        for (let i = 0; i < 26; i += 1) {
          html += `<spreadsheet-header type="column">${this.getColumnName(i)}</spreadsheet-header>`;
        }

        for (let i = 0; i < 100; i += 1) {
          html += `<spreadsheet-header type="row">${i}</spreadsheet-header>`;
          for (let j = 0; j < 26; j += 1) {
            const name = this.getColumnName(j) + i;
            this.cells.set(name, {
              name,
              value: NaN,
              formula: '',
              dependencies: [],
              height: 0,
              // TODO: optimize
              get input() {
                return document.querySelector(`input[name="${this.name}"]`);
              },
            });
            html += `<input name="${name}" type="text" on:focusin="EDIT_CELL" on:focusout="UPDATE_EXPRESSION" />`;
          }
        }

        this.innerHTML = html;
      }

      getColumnName(index) {
        return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[index % 26];
      }

      handleEvent(event) {
        const { intention, target } = findClosestIntention(event);

        switch (intention) {
          case 'EDIT_CELL': {
            const cell = this.cells.get(target.name);
            target.value = cell.formula;
            return;
          }
          case 'UPDATE_EXPRESSION': {
            const cell = this.cells.get(target.name);
            const newFormula = target.value.toUpperCase();

            if (cell.formula === newFormula) return;

            cell.formula = newFormula;

            // If there is a custom error then reset it.
            if (target.validity.customError) {
              target.setCustomValidity('');
            }

            cell.dependencies = (newFormula.match(/[A-Z]+\d+/g) ?? []).map((dep) =>
              this.cells.get(dep)
            );

            this.updateCellHeight(cell);

            return;
          }
        }
      }

      updateCellHeight(cell) {
        cell.height =
          cell.dependencies.length === 0
            ? 0
            : Math.max(...cell.dependencies.map((dep) => dep.height)) + 1;
      }

      topologicalSort(cell) {}

      evaluateCell(cell) {
        try {
          let formula = cell.formula;
          for (const cell of cell.dependencies) {
            formula = formula.replaceAll(cell.name, cell.value);
          }

          // TODO: unsafe eval, write custom parser/interpreter?
          cell.input.value = cell.value = eval(formula) ?? NaN;
        } catch {
          cell.input.setCustomValidity('Invalid formula.');
          cell.input.reportValidity();
        }
      }
    }

    SpreadsheetApp.register();
  </script>

  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
    }

    spreadsheet-app {
      display: grid;
      grid-template-columns: repeat(27, 100px);
      grid-template-rows: repeat(101, 1.75rem);
    }

    spreadsheet-header {
      background-color: rgb(226, 226, 226);
      border: 1px solid black;
      padding: 0.125rem 0.5rem;
    }

    input {
      border: 0.5px solid black;
      padding: 0.125rem 0.5rem;
      width: 100%;
      height: 100%;
    }
  </style>
</html>
